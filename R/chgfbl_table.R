#' Change from Baseline Table Caclulation Function 
#' 
#' @param data input data 
#' @param arm_var variable to use for arm/grouping 
#' 
#' @importFrom tidyr gather
#' @import forcats
#' 
#' @export
#' 
#' @author Chendi Liao (liaoc10), \email{chendi.liao@roche.com}
#' 
#' @examples 
#' 
#' library(tern)
#' library(random.cdisc.data)
#' 
#' ASL <- radam("ASL")
#' 
#' AQS <- merge(ASL, radam("AQS", ADSL = ASL)) %>% 
#'    filter(PARAMCD == "FATIGI")
#' 
#' df <- chgfbl_data(data = ANL)
#' 
#' \dontrun{
#' library(dplyr)
#' library(tidyr)
#' library(atezo.data)
#' library(teal.oncology)
#' library(forcats)
#' library(ggplot2)
#' library(grid)
#' library(gridExtra)
#' 
#' ASL <- asl(com.roche.cdpt7722.wo29637.rl)
#' AQS <- aqs(com.roche.cdpt7722.wo29637.rl)
#' 
#' #parammap <- unique(AQS[c("PARAM", "PARAMCD")]) 
#' 
#' ASL_f <- ASL %>% select(STUDYID, USUBJID, ARM, ARMCD)
#' AQS_f <- AQS %>% select(STUDYID, USUBJID, PARAMCD, PARAM, AVAL, AVISIT, AVISITN, ADY, ABLFL, APBFL, CHG, BASE)
#' #AVALU variable not available in AQS
#' #AQS_f$AVALU <- "kg/m^2"
#' 
#' ANL <- left_join(ASL_f, AQS_f, by = c("STUDYID", "USUBJID")) %>% filter(PARAMCD == "FATIGI")
#' 
#' df <- chgfbl_data(data = ANL)
#' chgfbl_plot(data = df, ytype = "CHG", errbar = "SE", ref_line = c(2, -2), fontsize = 14)
#' chgfbl_plot(data = df, ytype = "AVAL", errbar = "95CI", ref_line = 3, yrange = c(0,3), n_rotate = T)
#' 
#' tbl <- chgfbl_table(data=df)
#' Viewer(tbl)
#' 
#' 
#' 
#' \dontrun{
#' library(random.cdisc.data)
#' library(dplyr)
#' ASL <- radam("ASL")
#' ANL <- merge(ASL, radam("AQS", ADSL = ASL)) %>% filter(PARAMCD == "FATIGI")
#' 
#' df <- chgfbl_data(data = ANL)
#' chgfbl_plot(data = df, ytype = "CHG", errbar = "SE", ref_line = c(2, -2), fontsize = 14)
#' 
#' }
#' # now 
#' # chng_data <- ... # you already have this # do not export
#' # change_table(chng_data) # split by arm_name make columns and then combine
#' # change_plot(chng_data) # group_by(arm_name) make plotA
#' 
#' # maybe in future
#' # chng_table <- table...
#' # change_plot(chng_table)
#' # selection for chg_var can be "CHG" or "PCHG"
#' }
chgfbl_data <- function(data,
                        arm_var = "ARM"
                        ) {

  #####################
  # Argument checking #
  #####################
  
  if (any(is.na(data[[arm_var]]))) stop("currently cannot deal with missing values in arm")
  #if (!all(group_by %in% unique(data$PARAMCD))) stop("Selected parameters not found in analysis data")
  
  testdupvars <- c("STUDYID", "USUBJID",arm_var,"PARAMCD", "PARAM", "AVISIT", "AVISITN")
  
  #Remove any duplicated records and filter on param values
  if (!"AVALU" %in% names(data)) {data$AVALU <- NA_character_}
  data_f <- data[!duplicated(data[testdupvars]), c(testdupvars, "ABLFL","AVAL", "AVALU", "CHG")]
  data_f$CHG <- ifelse(is.na(data_f$CHG), ifelse(data_f$ABLFL == "Y", 0, NA),data_f$CHG)
  attr(data_f$CHG, "label") <- attr(data_f$AVAL, "label")
  
  #Convert AVAL and CHG from wide to long format
  df <- gather(data_f, type, value, AVAL, CHG) %>%
    mutate(arm = factor(.[[arm_var]]),
           arm_name = factor(paste(.[[arm_var]], type, sep="_")))
  
  if (all(is.na(df$value))) stop("Check data - there are no valid observations for the selected parameters")
  
  df.sum <- df %>% filter(!is.na(value)) %>%
    group_by(arm_name, arm, type, PARAMCD, PARAM, AVALU, AVISIT, AVISITN) %>%
    summarise(n = sum(!is.na(value)),
              mean = mean(value, na.rm=T),
              sd   = sd(value, na.rm=T),
              median = median (value, na.rm=T),
              q1   = quantile(value, 0.25, na.rm = T),
              q3   = quantile(value, 0.75, na.rm = T),
              min  = min(value, na.rm=T),
              max  = max(value, na.rm=T))
  
  df.final <- data.frame(df.sum) %>%
    mutate(visit = fct_reorder(factor(AVISIT), AVISITN)) %>%
    select(arm_name, arm, type, n:visit, PARAM, AVALU)
  
  df.final
} 



############################################################################
# Plotting function based on data from chgfbl_data
############################################################################
#' Plotting data generated from \code{chgfbl_data} into change from baseline
#' mean plot using ggplot2 and gridExtra
#' 
#' @param data data generated by \code{chgfbl_data} function
#' @param ytype type of value to plot for y-axis, possible values can be "AVAL",
#'   "CHG" or "PCHG"
#' @param errbar type of error bar to draw, possible values can be "SE", "SD",
#'   "95CI"
#' @param ref_line horizontal reference lines, must be either \code{NULL}
#'   (default), a single number or a numeric vector
#' @param yrange Range of y-axis to display in plot. If empty (default), range
#'   automatically controlled by ggplot2. Or must be a numeric vector of length
#'   of 2, with the first number smaller than second number.
#' @param fontsize Font size of text to be displayed on the plot
#' @param n_rotate logical value, \code{FALSE} is default, if \code{TRUE} text
#'   in the frequency table is rotated 90 degrees counterclockwise.
#'
#' @import ggplot2
#' @importFrom gridExtra grid.arrange  
#' 
#' @export
#' 
#' @author Chendi Liao (liaoc10), \email{chendi.liao@roche.com}
#'   
#' @examples
#' 
#' library(tern)
#' library(random.cdisc.data)
#' 
#' ASL <- radam("ASL")
#' 
#' ANL <- merge(ASL, radam("AQS", ADSL = ASL)) %>% 
#'    filter(PARAMCD == "FATIGI")
#' 
#' df <- chgfbl_data(data = ANL)
#' chgfbl_plot(data = df, ytype = "CHG", errbar = "SE", ref_line = c(2, -2), fontsize = 14)
#' 
chgfbl_plot <- function(data,
                        ytype = "CHG",
                        errbar = "SE",
                        ref_line = NULL,
                        yrange = NULL,
                        fontsize = 16,
                        n_rotate = TRUE) {
  
  ##Argument check ##
  if (!is.null(ref_line) && !is.numeric(ref_line)) stop("ref_line must be either empty or a numeric vector")
  if (!is.null(yrange)) {
    if (!is.numeric(yrange) || length(yrange) != 2) {
      stop("range for y-axis must be either empty or a numeric vector of length 2")
    } else if (yrange[1] >= yrange[2]) {
      stop("first number in y-axis range must be smaller than the second number")
    }
  }
  
  ## Calculate height of error bar depending on errbar type selection
  if (errbar == "SD") {
    data$ll = data$mean - data$sd
    data$ul = data$mean + data$sd
    errbar_name = "Standard Deviation"
  } else if (errbar == "SE") {
    data$ll = data$mean - data$sd/sqrt(data$n)
    data$ul = data$mean + data$sd/sqrt(data$n)
    errbar_name = "Standard Error of the Mean"
  } else if (errbar == "95CI") {
    data$ll = data$mean - 1.96*data$sd/sqrt(data$n)
    data$ul = data$mean + 1.96*data$sd/sqrt(data$n)
    errbar_name = "95% Confidence Interval of the Mean"
  } else if (errbar == "IQR") {
    data$ll = data$q1
    data$ul = data$q3
    errbar_name = "Interquartile Range"
  } else {data$errval = NA}
  
  ## Shorten visit names 
  visitcd <- data.frame(keywd = character(0), shortkey = character(0), stringsAsFactors = FALSE) %>%
    mapply(c, .,
           c("RANDOMIZATION", "R"), 
           c("CYCLE"       , "C"),
           c("DAY"        , "D"),
           c("FOLLOW-UP"   , "FU"),
           c("SURVIVAL"    , "S"),
           c("END OF TREATMENT", "EOT"),
           c("VISIT", " "), 
           c(" ", "")) %>%
    as.data.frame(.)
  
  shorten_visit <- function(x) {
    for (i in 1:nrow(visitcd)) {
      x <- gsub(visitcd$keywd[i], visitcd$shortkey[i], x)
    }
    x
  }

  ## Final data used for plotting
  # ll/ul = lower or upper bounds of error bar
  # visitlab = shortened visit name to display on x-axis
  # arm_short = shortened/re-formated arm name to display in table
  plotdat <- data %>% filter(type == ytype) %>%
    mutate(visitlab = fct_relabel(visit, shorten_visit), 
           arm_short = unlist(lapply(as.character(arm), reflow, limit=15)))
  
  ## Dynamically generate y-axis label
  yunit <- ifelse("AVALU" %in% names(plotdat), plotdat$AVALU[1], NA)
  
  ## Depending on y-axis variable, reference line at 0 plotted for CHG/PCHG, none plotted for AVAL by default
  if (ytype == "AVAL") {
    ytype_name <- "Value at Visit"
    ylabel <- ifelse(!is.na(yunit), paste(ytype_name, paste0("(",yunit,")")), ytype_name)
    plot_refline <- ifelse(!is.null(ref_line), 
                           list(geom_hline(yintercept = ref_line, color = "grey75", linetype = 2, size = 1)), list(NULL))
    
  } else if (ytype == "CHG") {
    ytype_name <- "Change from Baseline"
    ylabel <- ifelse(!is.na(yunit), paste(ytype_name, paste0("(",yunit,")")), ytype_name)
    plot_refline <- list(geom_hline(yintercept = 0, color = "grey75", size = 1),
      geom_hline(yintercept = c(ref_line, 0), color = "grey75", linetype = 2, size = 1))
   
  } else if (ytype == "PCHG") {
    ytype_name <- "Percent Change from Baseline"
    ylabel <- "Change from Baseline (%)"
    plot_refline <- list(geom_hline(yintercept = 0, color = "grey75", size = 1),
      geom_hline(yintercept = c(ref_line, 0), color = "grey75", linetype = 2, size = 1))
  }
  
  
  ## Dynamically generate title text and ylabel text
  title_text <- paste("Plot of Mean and", errbar_name,
                     "\n-", ytype_name, "of", plotdat$PARAM[1], "Score by Visit")
   
  ## If yrange specified, apply control to y-axis display range
  plot_yrange <- ifelse(!is.null(yrange), list(coord_cartesian(ylim= c(yrange[1], yrange[2]))), list(NULL))
  
  # move second group .2 to the left and right
  pd <- position_dodge(0.2) 
  
  #make change from baseline plot
  p <- ggplot(plotdat, aes(x = visitlab, y = mean, group = arm, color= arm)) + 
    plot_refline +
    plot_yrange + 
    geom_line(position=pd, size = 1) + 
    geom_point(position=pd) + 
    geom_errorbar(data = plotdat, aes(ymin = ll, ymax = ul), position=pd) +
    theme_bw() + labs(x = "Visits", y = ylabel, title = title_text) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          legend.position = "none", legend.background = element_rect(fill="grey95"),
          legend.direction = "horizontal", legend.title = element_text(face="bold"),
          axis.text.x = element_text(angle = 90, vjust = 0.5), 
          text = element_text(size=fontsize))
  
  #display count at each visit table as separate plot
  t <- ggplot(plotdat, aes(x = visitlab, y = fct_rev(factor(arm_short)), label = n, color = arm)) +
    geom_text(aes(angle = ifelse(isTRUE(n_rotate),90,0)), size = fontsize*0.3) + theme_bw() +
    labs(subtitle = "Number of subjects at each visit")
  t1 <- t + theme(legend.position="none", 
          axis.title.y = element_blank(),
          axis.text.y = element_text(color = rev(unique(ggplot_build(t)$data[[1]]$colour)), face = "bold"),
          axis.text.x = element_blank(), 
          axis.title.x = element_blank(), 
          axis.ticks.x = element_blank(),
          panel.grid = element_blank(), 
          text = element_text(size=fontsize)) 
  
  #wrap plot and table into grobs, and align left margins
  glist <- lapply(list(plot=p, text=t1), ggplotGrob)
  leftmar <- do.call(unit.pmax, lapply(glist, "[[", "widths"))
  glist.aligned <- lapply(glist, function(x) {
    x$widths <- leftmar
    x
  })
  
  
  #Plot the two grobs using grid.arrange
  grid.newpage()
  do.call(grid.arrange, c(glist.aligned, 
                          list(ncol=1), 
                          list(heights=c(8,length(unique(plotdat$arm))))))
  
}



############################################################################
# Table function based on data from chgfbl_data
############################################################################
#' Wrap data generated from \code{chgfbl_data} into rtable format, to create a
#' test result and change from baseline by visit summary table
#' 
#' @param data data generated by \code{chgfbl_data} function
#'   
#' @export
#' 
#' @author Chendi Liao (liaoc10), \email{chendi.liao@roche.com}
#'   
#' @examples
#' 
#' library(tern)
#' library(random.cdisc.data)
#' 
#' ASL <- radam("ASL")
#' 
#' ANL <- merge(ASL, radam("AQS", ADSL = ASL)) %>% 
#'    filter(PARAMCD == "FATIGI")
#' 
#' df <- chgfbl_data(data = ANL)
#' chgfbl_table(df)
#' 
chgfbl_table <- function(data) {
  
  df <- data %>%
    filter(!(visit == levels(visit)[1] & type != "AVAL"))
  
  col2type = unique(df$type)[!unique(df$type) %in% "AVAL"]
  
  result_sum <- lapply(split(df, df$visit), function(x) {
    lapply(split(x, x$arm_name), function(xi) {
      list(
        "n"         = rcell(xi$n, format = "xx"),
        "Mean (SD)" = rcell(c(xi$mean, xi$sd), format = "xx.x (xx.x)"),
        "Median"    = rcell(xi$median, format = "xx.x"),
        "IQR"       = rcell(c(xi$q1, xi$q3), format = "xx.xx - xx.xx"),
        "Min - Max" = rcell(c(xi$min, xi$max), format = "xx.xx - xx.xx")
      )
    })
  })
  
  #Helper functions for display with rtable
  lrrow <- function(row.name, l, ...) {
    do.call(rrow, c(list(row.name = row.name, ...), l))
  }
  
  out_sum <- Map(function(x, xname) {
    temp_row <- list_transpose(x)
    temp_block <- Map(lrrow, names(temp_row), temp_row, indent = 1)
    c(list(rrow(xname)),
      temp_block,
      list(rrow()))
  }, result_sum, as.list(names(result_sum)))
  
  
  ##########################################
  # Build output data structure with rtable#
  ##########################################3
  colname.n <- rep(unlist(out_sum[[1]][[2]]), each = 2)
  colname.txt <- names(colname.n) %>%
    vapply(function(x) reflow(x, limit = 15), character(1)) %>%
    sub("_.*$", "", .) %>%
    paste(c("Value at Visit", ifelse(col2type == "CHG", "Change from\nBaseline", 
                                     ifelse(col2type == "PCHG", "% Change from\nBaseline", NA_character_))), sep="\n")
    
  
  #--- Header Section ---#
  out_header <- list(
    col.names = paste0(colname.txt, '\n', "(N=", colname.n, ")"),
    format = "xx")
  
  
  tbl <- do.call(rtable, 
                 c(out_header, 
                   unlist(out_sum, recursive = F))
                 )
  
  tbl
}


### every line in dfi is an cell unit in table 
# dfi <- df.s[[1]]

### and a column in rtables lets make this later
# coli <- apply(dfi, 1, FUN = function(row) {
#   list(
#     rrow("name", indent = 1, ...),
#     ...
#   )
# })
# cbind(col1, col2, col3)



#########################################################################
# Helper functions                                                      #
#########################################################################
#' Helper functions to re-format and reflow long arm/grouping labels by inserting
#' line breaks
#' 
#' @param x input single string
#' @param delim delimiter, default is space
#' @param limit number of characters allowed before inserting line break,
#'   default is the maximum length of longest word
#'   
#' @export
#' 
#' @author Chendi Liao (liaoc10), \email{chendi.liao@roche.com}
#'   
#' @examples 
#' 
#' x = "hellO-world abcerewerwere testing "
#' reflow(x)
#' reflow(x, delim = "-")
#' reflow(x, limit= 9)
#' 
reflow <- function(x, 
                   delim = " ", 
                   limit = NULL) {
  
  xsplit <- unlist(strsplit(x, delim))
  ctxt = ""
  n = 0
  
  if (is.null(limit)) {limit <- max(unlist(lapply(xsplit, nchar)))}
  
  for (i in xsplit) {
    if (nchar(i) > limit) {
      ctxt <- ifelse(n, paste0(ctxt, "\n", i, "\n"), paste0(ctxt, i, "\n"))
      n = 0
    } else if ((n + nchar(i)) > limit) {
      ctxt <- paste0(ctxt, "\n", i)
      n = nchar(i)
    } else {
      ctxt <- ifelse(n, paste0(ctxt, delim, i), paste0(ctxt, i))
      n = n + nchar(i)
    }
  }
  
  outtxt <- ifelse(substring(ctxt, nchar(ctxt)) == "\n", substr(ctxt, 1, nchar(ctxt)-1), ctxt)
  
  outtxt
}
