---
title: "Design for AE by grade table (LBT04)"
author: "Jana Stoilova"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Data for examples
=================
```{r, data}

library(scda)

adlb <- synthetic_cdisc_data("rcd_2021_05_05")$adlb
adsl <- synthetic_cdisc_data("rcd_2021_05_05")$adsl

# Recode ADLB parameters to so that each one has different
# possible abnormalities
# ALT: LOW
# IGA: HIGH
# CRP: LOW, HIGH

adlb$ANRIND[adlb$PARAMCD == "ALT" & adlb$ANRIND == "HIGH"] <- "LOW"
adlb$BNRIND[adlb$PARAMCD == "ALT" & adlb$BNRIND == "HIGH"] <- "LOW"

adlb$ANRIND[adlb$PARAMCD == "IGA" & adlb$ANRIND == "LOW"] <- "HIGH"
adlb$BNRIND[adlb$PARAMCD == "IGA" & adlb$BNRIND == "LOW"] <- "HIGH"

adlb %>% count(PARAMCD, BNRIND, ANRIND)

```

# Current functionality

Our goal is to re-desing the `count_abnormal` layout so that based on a metadata map, the row with "High" records under ALT and "Low" records under IGA can be removed.
```{r, current}
lyt <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

result <- build_table(lyt = lyt, df = adlb, alt_counts_df = adsl)

result
```


# New rtables split function

This will be available soon.
```{r, split_fun}
keep_split_levels_of_vars3 <- function(map = NULL) {
  
  if (is.null(map) || any(sapply(map, class) != "character"))
    stop("No map dataframe was provided or not all of the columns are of type character.")
  
  myfun <- function(df, spl, vals = NULL, labels = NULL, trim = FALSE) {
    
    allvars <- colnames(map)
    splvar <- rtables:::spl_payload(spl)
    outvars <- allvars[-(which(allvars == splvar):length(allvars))]

    ## handle conditioning on outer variables (if any), 
    ## subset the map depending on where we are in the split tree
    if (outvars != "") {
      outvars_levs <- unique(df[, outvars])[ , , drop = TRUE]
      if (!is.null(dim(outvars_levs)))
        stop ("Outer variables were not specified correctly in the map.")
      outvars_filter <- paste(paste(outvars, paste0("'", outvars_levs, "'"), sep = " == "), 
                              collapse = " & ")
      map <- subset(map, subset = eval(parse(text = outvars_filter)), select = setdiff(allvars, outvars))
      map <- unique(map)
    }

    ## handle split variable
    nondup <- !duplicated(map[[splvar]])
    ksl_fun <- keep_split_levels(only = map[[splvar]][nondup], reorder = TRUE)
    ret <- ksl_fun(df, spl, vals, labels, trim = trim)
    
    ## keep non-split (inner) variables levels
    ret$datasplit <- lapply(ret$values, function(splvar_lev) {

      df3 <- ret$datasplit[[splvar_lev]]
      
      # loop through inner variables 
      for (iv in setdiff(colnames(map), splvar)) { 
        iv_lev <- df3[[iv]]
        levkeep <- as.character(na.omit(unique(map[map[, splvar] == splvar_lev, iv])))
        if (is.factor(iv_lev) && !all(levkeep %in% levels(iv_lev)))
          stop("Attempted to keep invalid factor level(s) in split ", setdiff(levkeep, levels(iv_lev)))
        
        df3 <- df3[iv_lev %in% levkeep, , drop = FALSE]
        
        if (is.factor(iv_lev))
          df3[[iv]] <- factor(as.character(df3[[iv]]), levels = levkeep)
      }
      
      df3
    })
    names(ret$datasplit) <- ret$values
    ret
  }
  
  myfun
}

```

# Metadata map

Defines which lab directions are theoretically possible even if they don't exist in the dataset.

```{r, metadata}

map <- data.frame(
  LBCAT = c("CHEMISTRY", "CHEMISTRY", "CHEMISTRY", "IMMUNOLOGY"),
  PARAMCD = c("ALT", "CRP", "CRP", "IGA"),
  ANRIND = c("LOW", "LOW", "HIGH", "HIGH"),
  stringsAsFactors = FALSE
)

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = keep_split_levels_of_vars3(map = map)) %>%
  analyze("ANRIND") %>%
  build_table(adlb)
```


# Statistics function

Here we update the default `abnormal` to be for multiple directions (previously was either LOW or HIGH). The function will return a list depending on the intersection of the factor levels available in the analysis variable `.var` and the values of `abnormal`.

```{r, sfun}

s_count_abnormal <- function(df,
                             .var,
                             abnormal = c("LOW", "HIGH"),
                             variables = list(id = "USUBJID", baseline = "BNRIND"),
                             exclude_base_abn = FALSE
) {

  abn_levels <- intersect(abnormal, levels(df[[.var]]))
  
  result <- split(numeric(0), factor(abn_levels, levels = abn_levels))
  
  for (abn in abn_levels) {
    
    abnormal <- abn
    
    # Patients in the denominator fulfill:
    # - have at least one post-baseline visit
    # - their baseline must not be abnormal if `exclude_base_abn`.
    subjects_post_any <- df[[variables$id]]
    subjects_exclude <- if (exclude_base_abn) {
      df[df[[variables$baseline]] == abnormal, ][[variables$id]]
    } else {
      c()
    }
    subjects_denom <- setdiff(subjects_post_any, subjects_exclude)
    denom <- length(subjects_denom)
    
    # Patients in the numerator fulfill:
    # - have at least one post-baseline visit with the required abnormality level
    # - are part of the denominator patients.
    subjects_post_abnormal <- df[df[[.var]] == abnormal, ][[variables$id]]
    subjects_num <- intersect(subjects_post_abnormal, subjects_denom)
    num <- length(subjects_num)
    
    result[[abn]] <- with_label(c(num = num, denom = denom), abn)
    
  }

  result <- list(fraction = result)
  result
}

# Test it out.
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")

```

```{r, afun}
# No changes here.

a_count_abnormal <- make_afun(
  s_count_abnormal,
  .formats = c(fraction = format_fraction)
)
```

# New layout function

Here the main change is using the `.ungroup_stats` argument.

```{r, new_layout}

count_abnormal <- function(lyt,
                           var,
                           abnormal,
                           ...,
                           table_names = var,
                           .stats = NULL,
                           .formats = NULL,
                           .labels = NULL,
                           .indent_mods = NULL) {

  afun <- make_afun(
    a_count_abnormal,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels,
    .indent_mods = .indent_mods,
    .ungroup_stats = "fraction"
  )
  assert_that(
    is.string(var)
  )

  analyze(
      lyt = lyt,
      vars = var,
      afun = afun,
      table_names = table_names,
      extra_args = c(list(abnormal = abnormal), list(...)),
      show_labels = "hidden"
    )
  
}

# Not quite right yet. 
basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = keep_split_levels_of_vars3(map = map)) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c("LOW", "HIGH"),
    exclude_base_abn = FALSE
  ) %>%
  build_table(adlb, alt_counts_df = adsl)

```
