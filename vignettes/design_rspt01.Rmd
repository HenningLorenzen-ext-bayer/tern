---
title: "Design: Best overall response (RSPT01)"
author: "Francois Collin"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{design_rspt01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/ref/references.bib

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```


Configuration
=============

```{r setup}
library(rtables)
library(tern)

packageVersion("tern")
packageVersion("rtables")
```

From old tern `get_onco_rsp_label()` becomes `label_onco_rsp()`.

```{r label_onco_rsp}
#' Label oncology responses
#'
#' This is a convenience function for standard labeling of oncological
#' responses
#'
#' @return Named \code{character} vector.
#'
#' @export
#'
#' @examples
#' rsp <- c("CR", "NE", "PR")
#'
#' # Recode values with standard labels.
#' rsp <- label_onco_rsp()[ match(rsp, names(get_onco_rsp_label()))  ]
#'
#' rsp <- factor(rsp, levels = get_onco_rsp_label())

get_onco_rsp_label <- function() {

  rsp_full_label <- c(
    CR          = "Complete Response (CR)",
    PR          = "Partial Response (PR)",
    SD          = "Stable Disease (SD)",
    `NON CR/PD` = "Non-CR or Non-PD (NON CR/PD)",
    PD          = "Progressive Disease (PD)",
    NE          = "Not Evaluable (NE)",
    Missing     = "Missing",
    `NE/Missing` = "Missing or unevaluable"
  )
  rsp_full_label
}
```

```{r data, results = "asis", eval = TRUE}
library(dplyr)
library(random.cdisc.data)
ADSL <- radsl(cached = TRUE)
ADRS <- radrs(cached = TRUE)

# Select a response parameter endpoint.
ADRS_f <- ADRS %>% filter(PARAMCD == "INVET")

# Recode multinomial response with standard oncology labels.
levels(ADRS_f$AVALC) <- get_onco_rsp_label()[
  match(levels(ADRS_f$AVALC), names(get_onco_rsp_label()))
  ]

# Response variable.
ADRS_f <- ADRS_f %>%
  select(ARMCD, AVALC, SEX) %>%
  mutate(
    is_rsp = AVALC %in% c("Complete Response (CR)", "Partial Response (PR)")
  )
# Outlook.
knitr::kable(head(ADRS_f))
```


Execution
=========

Estimate proportion {.tabset}
-----------------------------

### Application

```{r estimate_proportion}
dta_test <- data.frame(X = c(1, 0, 1, 0))
l <- estimate_proportion(lyt = NULL, vars = "X")

build_table(lyt = l, df = dta_test)
```

```{r s_proportion}
s_proportion(c(1, 0, 1, 0))
```

### Functions

- `prop_wilson()`
- `prop_clopper_pearson()`
- `prop_wald()`
- `prop_agresti_coull()`
- `prop_jeffreys()`
- `s_proportion()`
- `estimate_proportion()`
- `d_proportion()`

```{r estimate_proportion.R, engine='bash', comment=''}
cat ../R/estimate_proportion.R
```


Estimate proportion differences {.tabset}
-----------------------------------------


### Application

```{r estimate_proportion_diff_app}
# Wald confidence interval

set.seed(2)
rsp <- sample(c(TRUE, FALSE), replace = TRUE, size = 20)
grp <- c(rep("A", 10), rep("B", 10))
prop_diff_wald(rsp = rsp, grp = grp, conf_level = 0.90, correct = FALSE)

# Anderson-Hauck confidence interval

## "Mid" case: 3/4 respond in group A, 1/2 respond in group B.
rsp <- c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
grp <- factor(c("A", "B", "A", "B", "A", "A"), levels = c("B", "A"))
prop_diff_ha(rsp = rsp, grp = grp, conf_level = 0.90)

## Edge case: Same proportion of response in A and B.
rsp <- c(TRUE, FALSE, TRUE, FALSE)
grp <- factor(c("A", "A", "B", "B"), levels = c("A", "B"))
prop_diff_ha(rsp = rsp, grp = grp, conf_level = 0.6)


# Newcombe confidence interval

set.seed(1)
rsp <- c(
  sample(c(TRUE, FALSE), size = 40, prob = c(3/4, 1/4), replace = TRUE),
  sample(c(TRUE, FALSE), size = 40, prob = c(1/2, 1/2), replace = TRUE)
)
grp <- factor(rep(c("A", "B"), each = 40), levels = c("B", "A"))
table(rsp, grp)
prop_diff_nc(rsp = rsp, grp = grp, conf_level = 0.9)


# Cochran-Mantel-Haenszel confidence interval

set.seed(2)
rsp <- sample(c(TRUE, FALSE), 100, TRUE)
grp <- sample(c("Placebo", "Treatment"), 100, TRUE)
grp <- factor(grp, levels = c("Placebo", "Treatment"))
strata_data <- data.frame(
  "f1" = sample(c("a", "b"), 100, TRUE),
  "f2" = sample(c("x", "y", "z"), 100, TRUE),
  stringsAsFactors = TRUE)

prop_diff_cmh(
  rsp = rsp, grp = grp, strata = interaction(strata_data),
  conf_level = 0.90
)


# Summary

## "Mid" case: 4/4 respond in group A, 1/2 respond in group B.
dta <- data.frame(
  rsp = c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE),
  grp = factor(c("A", "B", "A", "B", "A", "A"), levels = c("B", "A"))
)

s_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  conf_level = 0.90,
  method = "ha"
)


l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  estimate_proportion_diff(
    vars = "rsp",
    conf_level = 0.90,
    method = "ha"
  )

build_table(l, df = dta)

```

### Functions

- `check_diff_prop_ci()`
- `d_proportion_diff()`
- `prop_diff_wald()`
- `prop_diff_ha()`
- `prop_diff_nc()`
- `prop_diff_cmh()`
- `s_proportion_diff()`
- `estimate_proportion_diff()`

```{r prop_diff.R, engine='bash', comment=''}
cat ../R/prop_diff.R
```


Test proportion difference {.tabset}
------------------------------------

### Application

### Functions

- `prop_chisq()`
- `prop_cmh()`
- `prop_schouten()`
- `prop_fisher()`

```{r test_proportion_diff.R, engine='bash', comment=''}
cat ../R/test_proportion_diff.R
```

Estimate Odds Ratio {.tabset}
-----------------------------

### Application

### Functions

- `or_glm()`
- `s_odds_ratio()`

```{r odds_ratio.R, engine='bash', comment=''}
cat ../R/odds_ratio.R
```

### Limits

#### `or_clogit` - wrong implementation

```{r}
library(survival)
#' OR with Strata by Conditional Likelihood
#'
#' The odds ratio is estimated by conditional likelihood using
#' [survival::clogit()].
#'
#' @inheritParams argument_convention
#' @param data (`data frame`)\cr
#'   includes the three variables `rsp`, `grp` and `strata`.
#' @importFrom survival strata clogit coxph
or_clogit <- function(data, conf_level) {

  # Deviation from convention: `survival::strata` must be simply `strata`.
  formula <- stats::as.formula("rsp ~ grp + strata(strata)")
  model_fit <- survival::clogit(formula = formula, data = data)

  list(
    or_ci = c(
      exp(stats::coef(model_fit)),
      exp(stats::confint(model_fit, level = conf_level))
    )
  )

}
```

The `clogit`-based prototype is flawed as the OR estimates obtained for a
model fitted on data subset is not equivalent to the estimates based on the
complete dataset. This is typically the case of `rtables` workflow working
by column (eventually in comparison to a reference):

```{r}
data <- data.frame(
  rsp = as.logical(c(1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)),
  grp =    letters[c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3)],
  strata = LETTERS[c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)]
)

data <- subset(data, grp %in% c("a", "b"))
data$grp <- droplevels(data$grp)
or_clogit(data, conf_level = 0.95)

data <- data.frame(
  rsp = as.logical(c(1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)),
  grp =    letters[c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3)],
  strata = LETTERS[c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)]
)

data$grp <- droplevels(data$grp)
or_clogit(data, conf_level = 0.95)
```


Design Proposition
==================

The final functions should make this workable:

```{r target, eval = FALSE}
lyt <- split_cols_by(lyt = NULL, var = "ARMCD", ref_group = ref) %>%
  add_colcounts %>%
  estimate_proportion(
    vars = "is_rsp",
    conf_level = 0.9, prop_ci_method = "clopper-pearson"
    ) %>%
  estimate_proportion_diff(vars = "is_rsp", conf_level = 0.91) %>%
  test_proportion_diff(vars = "is_rsp") %>%
  estimate_odds_ratio(vars = "is_rsp") %>%
  estimate_multinomial_response(var = "AVALC")

as_html(build_table(lyt = lyt, df = ADRS_f))
```




Test proportion diff
--------------------

### Functions {.tabset}

#### `d_test_proportion_diff`

Not exported.

```{r}
#' Description of the Test Between Two Proportions
#'
#' This is an auxiliary function that describes the analysis in
#  `s_test_proportion_diff`.
#'
#' @inheritParams s_test_proportion_diff
#' @return String describing the test from which the p-value is derived.
d_test_proportion_diff <- function(method) {
  meth_part <- switch(
    method,
    "schouten" = "Chi-Squared Test with Schouten Correction",
    "chisq" = "Chi-Squared Test",
    "cmh" = "Cochran-Mantel-Haenszel Test",
    "fisher" = "Fisher's Exact Test",
    stop(paste(method, "does not have a description"))
  )
  paste0("p-value (", meth_part, ")")
}
```


#### `s_test_proportion_diff` [PR 658](https://github.roche.com/NEST/tern/pull/658/)

```{r}
#' @describeIn prop_diff_test Statistics function which test the difference
#'  between two proportions.
#'
#' @inheritParams argument_convention
#' @param .ref_group The data corresponding to the reference group.
#' @param .in_ref_col Logical to specify result in reference column.
#' @param diff_ci_method The method used for the confidence interval estimation.
#' @param method (`string`)\cr
#'   one of (`chisq`, `cmh`, `fisher`, `schouten`; specifies the test used
#'   to calculate the p-value.
#'
#' @return Named `list` with a single item `pval` with an attribute `label`
#'   describing the method used. The p-value tests the null hypothesis that
#'   proportions in two groups are the same.
#' @export
#' @examples
#'
#' dta <- data.frame(
#'   rsp = sample(c(TRUE, FALSE), 100, TRUE),
#'   grp = factor(rep(c("A", "B"), each = 50)),
#'   strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' )
#'
#' s_test_proportion_diff(
#'   df = subset(dta, grp == "A"),
#'   .var = "rsp",
#'   .ref_group = subset(dta, grp == "B"),
#'   .in_ref_col = FALSE,
#'   variables = list(strata = "strat"),
#'   method = "cmh"
#' )
#'
s_test_proportion_diff <- function(df,
                                   .var,
                                   .ref_group,
                                   .in_ref_col,
                                   variables = list(strata = NULL),
                                   method = c(
                                     "schouten", "chisq", "cmh", "fisher"
                                     )
                                   ) {

  method <- match.arg(method)
  y <- list(pval = "")

  if (!.in_ref_col) {

    rsp <- c(.ref_group[[.var]], df[[.var]])
    grp <- factor(
      rep(c("ref", "Not-ref"), c(nrow(.ref_group), nrow(df))),
      levels = c("ref", "Not-ref")
    )

    if (!is.null(variables$strata)) {
      strata <- variables$strata
      strata <- c(interaction(.ref_group[[strata]]), interaction(df[[strata]]))
    }

    tbl <- if(method == "cmh")
      table(grp, rsp, strata)
    else
      table(grp, rsp)

    y$pval <- switch(
      method,
      chisq = prop_chisq(tbl),
      cmh = prop_cmh(tbl),
      fisher = prop_fisher(tbl),
      schouten = prop_schouten(tbl)
    )

  }

  y$pval <- with_label(y$pval, d_test_proportion_diff(method))
  y
}

```

#### `test_proportion_diff` [PR 658](https://github.roche.com/NEST/tern/pull/658/)

```{r test_proportion_diff}
#' @describeIn prop_diff_test Layout creating function which can be used for
#'   creating tables, which can take statistics function arguments and
#'   additional format arguments.
#' @export
#' @examples
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   test_proportion_diff(
#'     vars = "rsp",
#'     method = "fisher"
#'   )
#'
#' build_table(l, df = dta)
#'
test_proportion_diff <- function(lyt,
                                 vars,
                                 ...) {

  afun <- format_wrap_df(
    sfun = s_test_proportion_diff,
    formats =  c(pval = "x.xxxx | (<0.0001)"),
    indent_mods = c(pval = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}
```


### Applications

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

d_test_proportion_diff
s_test_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  variables = list(strata = "strat"),
  method = "cmh"
)

```

```{r}
l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  test_proportion_diff(
    vars = "rsp",
    method = "fisher"
  )

build_table(l, df = dta)
```


Estimate odds ratio [PR 656](https://github.roche.com/NEST/tern/pull/656)
-------------------

### Functions {.tabset}


#### `estimation_odds_ratio` [PR 656](https://github.roche.com/NEST/tern/pull/656)

```{r}
#' @describeIn abnormal Layout creating function which can be used for creating
#'   tables, which can take statistics function arguments and additional format
#'   arguments (see below).
#' @export
#' @examples
#'
#' dta <- data.frame(
#'   rsp = sample(c(TRUE, FALSE), 100, TRUE),
#'   grp = factor(rep(c("A", "B"), each = 50)),
#'   strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' )
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   estimation_odds_ratio(vars = "rsp")
#'
#' build_table(l, df = dta)
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   estimation_odds_ratio(vars = "rsp", variables = list(strata = "strat"))
#'
#' build_table(l, df = dta)
#'
estimation_odds_ratio <- function(lyt,
                                  vars,
                                  ...) {

  afun <- format_wrap_df(
    sfun = s_odds_ratio,
    formats =  c(or_ci = function(x, output) {
      x <- round(x, 2)
      paste0(x[1], " (", x[2], " - ", x[3], ")")
    }
    ),
    indent_mods = c(or_ci = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}

```

### Application

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

s_odds_ratio(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE
)
```

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50))
)

l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  estimation_odds_ratio(vars = "rsp")

build_table(l, df = dta)

l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  estimation_odds_ratio(vars = "rsp")

build_table(l, df = dta)

```


Estimate multinomial response
-----------------------------

### Functions {.tabset}

#### `d_onco_rsp_label`

The function `d_onco_rsp_label()` is the renamed `get_onco_rsp_label()`:

```{r d_onco_rsp_label}
#' Standard oncology response
#'
#' Describe the oncology response.
#'
#' @return Named \code{character} vector.
#'
#' @export
#'
#' @examples
#'
#' rsp <- c("CR", "NE", "PR")
#'
#' # Recode values with standard labels.
#' rsp <- d_onco_rsp_label()[match(rsp, names(get_onco_rsp_label()))]
#'
#' # Create factor.
#' rsp <- factor(rsp, levels = get_onco_rsp_label())
#'
d_onco_rsp_label <- function() {

  rsp_full_label <- c(
    CR          = "Complete Response (CR)",
    PR          = "Partial Response (PR)",
    SD          = "Stable Disease (SD)",
    `NON CR/PD` = "Non-CR or Non-PD (NON CR/PD)",
    PD          = "Progressive Disease (PD)",
    NE          = "Not Evaluable (NE)",
    Missing     = "Missing",
    `NE/Missing` = "Missing or unevaluable"
  )
  rsp_full_label
}

```

#### `s_multinomial_response`

#### `s_multinomial_response`

```{r s_multinomial_response}
library(assertthat)
d_proportion <- tern:::d_proportion
h_prop_ci <- function(rsp, n, x, n_total, method, conf_level, long = long) {
  
  z <- list()
  z$n_prop <- with_label(x = c(n, n/n_total), label = as.character(unique(x)))
  
  prop_ci <- switch(
    method,
    "clopper-pearson" = prop_clopper_pearson(rsp, conf_level),
    wilson = prop_wilson(rsp, conf_level),
    wald = prop_wald(rsp, conf_level),
    waldcc = prop_wald(rsp, conf_level, correct = TRUE),
    "agresti-coull" = prop_agresti_coull(rsp, conf_level),
    jeffreys = prop_jeffreys(rsp, conf_level)
  )
  
  z$prop_ci <- with_label(
    x = prop_ci,
    label = d_proportion(conf_level, method, long = long)
  )
  
  z
  
}
#' @inheritParams argument_convention
#' @inheritParams s_proportion estimate the proportion of outcomes per factor level.
#'
#' @describeIn multinomial_response statistics function estimating a
#'   proportion per factor level along with its confidence interval for the level.
#'
#' @export
#' @order 3
#' @examples
#'
#' s_multinomial_response(c(0, 1, 0, 1), .N_col = 20)
#'
s_multinomial_response <- function(x,
                                   conf_level = 0.95,
                                   method = c(
                                     "waldcc", "wald", "clopper-pearson",
                                     "wilson", "agresti-coull", "jeffreys"
                                   ),
                                   long = FALSE) {
  
  method <- match.arg(method)
  assert_that(
    conf_level >= 0,
    conf_level <= 1,
    is.flag(long)
  )
  
  n_total <- length(x)
  x <- split(x, f = x)
  n <- lapply(x, length)
  rsp <- lapply(n, function(z) rep(c(TRUE, FALSE), c(z, n_total - z)))
  
  y <- mapply(
    rsp = rsp, n = n, x = x, n_total = n_total, method = method,
    conf_level = conf_level, long = long,
    SIMPLIFY = FALSE, FUN = h_prop_ci
  )
  
  tern:::flatten_list(y)
  
}
```

#### `estimate_multinomial_response`

Problem:

- Should we change the assertions behind `indent_mods` argument?
    + If ` indent_mods = c(prop_ci = -1L)`, then
    `Error: Elements 1 of sapply(indent_mods, is_nonnegative_count) are not true`.

```{r}
#' @inheritParams rtables::analyze
#' @param ... other arguments are ultimately conveyed to [s_multinomial_response()].
#' @export
#' @describeIn multinomial_response used in a `rtables` pipeline.
#' @order 4
#' @template formatting_arguments
#' @examples
#' 
#' dta_test <- data.frame(
#'   USUBJID = paste0("S", 1:12),
#'   ARM     = rep(LETTERS[1:3], each = 4),
#'   AVAL    = c(A = c(1, 1, 1, 1), B = c(0, 0, 1, 1), C = c(0, 0, 0, 0))
#' )
#' dta_test$AVALC <- as.factor(c(
#'   "Complete Response (CR)", "Partial Response (PR)"
#' )[dta_test$AVAL + 1])
#'
#' lyt <- split_cols_by(lyt = NULL, var = "ARM") %>%
#'   estimate_multinomial_response(var = "AVALC")
#'
#' as_html(build_table(lyt = lyt, df = dta_test))
#'
estimate_multinomial_response <- function(lyt,
                                          var,
                                          vars = var,
                                          ...) {

  afun <- format_wrap_x(
    sfun = s_multinomial_response,
    formats =  c(n_prop = "xx (xx.xx%)", prop_ci = "(xx.xx, xx.xx)"),
    indent_mods = c(n_prop = 0L, prop_ci = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}

```

### Application {.tabset .tabset-pills}

```{r}
library(dplyr)
library(random.cdisc.data)
ADSL <- radsl(cached = TRUE)
ADRS <- radrs(cached = TRUE)

# Select a response parameter endpoint.
ADRS_f <- ADRS %>% filter(PARAMCD == "INVET")

# Recode multinomial response with standard oncology labels.
levels(ADRS_f$AVALC) <- d_onco_rsp_label()[
  match(levels(ADRS_f$AVALC), names(d_onco_rsp_label()))
  ]

# Response variable.
ADRS_f <- ADRS_f %>%
  select(ARMCD, AVALC, SEX) %>%
  mutate(is_rsp = AVALC %in% c("Complete Response (CR)", "Partial Response (PR)"))

# Outlook.
knitr::kable(head(ADRS_f))
```

```{r}
x <- ADRS_f$AVALC[ADRS$ARMCD == "ARM A"]
s_multinomial_response(x = x)
```

```{r}
lyt <- split_cols_by(lyt = NULL, var = "ARMCD", ref_group = "ARM A") %>%
  estimate_multinomial_response(var = "AVALC", .indent_mods = c(prop_ci = 2L))
as_html(build_table(lyt = lyt, df = ADRS_f))
```



Combined layers
---------------

Problem:

- `estimate_multinomial_response()` involves an `analyze` a row split.
  Because it is not possible to add a new split after an analyze, and
  because `estimate_multinomial_response()` is presented in RSPT01 after
  proportion estimation, proportion difference test and other, we need to find 
  a work around to make `estimate_multinomial_response()` compatible with the
  other layout creating functions. Maybe `rbind()`?
  
```{r}
lyt <- split_cols_by(lyt = NULL, var = "ARMCD", ref_group = "ARM A") %>%
  estimate_proportion(vars = "is_rsp") %>%
  estimate_proportion_diff(vars = "is_rsp") %>%
  test_proportion_diff(vars = "is_rsp") %>%
  estimate_multinomial_response(var = "AVALC")

as_html(build_table(lyt = lyt, df = ADRS_f)) %>% Viewer
```


References
==========
