---
title: "Design: Best overall response (RSPT01)"
author: "Francois Collin"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{design_rspt01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/ref/references.bib

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```


Configuration
=============

```{r setup}
library(rtables)
library(tern)

packageVersion("tern")
packageVersion("rtables")
```

From old tern `get_onco_rsp_label()` becomes `label_onco_rsp()`.

```{r label_onco_rsp}
#' Label oncology responses
#'
#' This is a convenience function for standard labeling of oncological
#' responses
#'
#' @return Named \code{character} vector.
#'
#' @export
#'
#' @examples
#' rsp <- c("CR", "NE", "PR")
#'
#' # Recode values with standard labels.
#' rsp <- label_onco_rsp()[ match(rsp, names(get_onco_rsp_label()))  ]
#'
#' rsp <- factor(rsp, levels = get_onco_rsp_label())

get_onco_rsp_label <- function() {

  rsp_full_label <- c(
    CR          = "Complete Response (CR)",
    PR          = "Partial Response (PR)",
    SD          = "Stable Disease (SD)",
    `NON CR/PD` = "Non-CR or Non-PD (NON CR/PD)",
    PD          = "Progressive Disease (PD)",
    NE          = "Not Evaluable (NE)",
    Missing     = "Missing",
    `NE/Missing` = "Missing or unevaluable"
  )
  rsp_full_label
}
```

```{r data, results = "asis", eval = TRUE}
library(dplyr)
library(random.cdisc.data)
ADSL <- radsl(cached = TRUE)
ADRS <- radrs(cached = TRUE)

# Select a response parameter endpoint.
ADRS_f <- ADRS %>% filter(PARAMCD == "INVET")

# Recode multinomial response with standard oncology labels.
levels(ADRS_f$AVALC) <- get_onco_rsp_label()[
  match(levels(ADRS_f$AVALC), names(get_onco_rsp_label()))
  ]

# Response variable.
ADRS_f <- ADRS_f %>%
  select(ARMCD, AVALC, SEX) %>%
  mutate(
    is_rsp = AVALC %in% c("Complete Response (CR)", "Partial Response (PR)")
  )
# Outlook.
knitr::kable(head(ADRS_f))
```



Design Proposition
==================

The final functions should make this workable:

```{r target, eval = FALSE}
lyt <- split_cols_by(lyt = NULL, var = "ARMCD", ref_group = ref) %>%
  add_colcounts %>%
  estimate_proportion(
    vars = "is_rsp",
    conf_level = 0.9, prop_ci_method = "clopper-pearson"
    ) %>%
  estimate_proportion_diff(vars = "is_rsp", conf_level = 0.91) %>%
  test_proportion_diff(vars = "is_rsp") %>%
  estimate_odds_ratio(vars = "is_rsp") %>%
  estimate_multinomial_response(var = "AVALC")

as_html(build_table(lyt = lyt, df = ADRS_f))
```


Estimate proportion {.tabset}
-------------------

Based on the existing (minor refactoring):

- topic name: `Responder proportions`
- `estimate_proportion`, this layer function  needs:
    + `s_proportion`, needs:
        - `d_proportion` for row labeling.
    + `format_wrap_x`


### Functions {.tabset .tabset-pills}


#### `estimate_proportion`

```{r}
estimate_proportion <- function(lyt,
                                vars,
                                ...) {
  
  analyze(
    lyt,
    vars,
    afun = format_wrap_x(
      s_proportion,
      formats =  c(
        n = "xx", prop = "xx.x%", n_prop = "xx (xx.xx%)",
        prop_ci = "(xx.xx, xx.xx)"
      ),
      indent_mods =  c(n = 0L, prop = 0L, n_prop = 0L, prop_ci = 0L)
    )
    
  )
  
}
```

#### `s_proportion`

I would keep most of `s_proportion` as already defined in old tern
(minor modification about the labeling).

```{r}
s_proportion <- function(x, conf_level = 0.95,
                         prop_ci_method = c(
                           "waldcc", "wald", "clopper-pearson",
                           "wilson", "agresti-coull", "jeffreys"
                         )
) {

  # check_is_event(x) # TODO - adapt after redesign
  prop_ci_method <- match.arg(prop_ci_method)
  ## check_conf_level(conf_level)  # TODO - adapt after redesign

  # Common variables used below.
  n <- length(x)
  x_sum <- sum(x)
  p_hat <- mean(x)
  z <- qnorm((1 + conf_level) / 2)

  # Calculate CI.
  prop_ci <- if (prop_ci_method == "clopper-pearson") {

    as.numeric(binom.test(x_sum, n, conf.level = conf_level)$conf.int)

  } else if (prop_ci_method == "wilson") {

    as.numeric(prop.test(x_sum, n, correct = FALSE, conf.level = conf_level)$conf.int)

  } else if (prop_ci_method %in% c("wald", "waldcc")) {

    q_hat <- 1 - p_hat
    correct <- ifelse(
      prop_ci_method == "waldcc",
      1 / (2 * n),
      0
    )
    err <- z * sqrt(p_hat * q_hat) / sqrt(n) + correct
    l_ci <- max(0, p_hat - err)
    u_ci <- min(1, p_hat + err)

    c(l_ci, u_ci)

  } else if (prop_ci_method == "agresti-coull") {

    # Add here both z^2 / 2 successes and failures.
    x_sum_tilde <- x_sum + z^2 / 2
    n_tilde <- n + z^2
    # Then proceed as with the Wald interval.
    p_tilde <- x_sum_tilde / n_tilde
    q_tilde <- 1 - p_tilde
    err <- z * sqrt(p_tilde * q_tilde) / sqrt(n_tilde)
    l_ci <- max(0, p_tilde - err)
    u_ci <- min(1, p_tilde + err)

    c(l_ci, u_ci)

  } else if (prop_ci_method == "jeffreys") {

    alpha <- 1 - conf_level
    l_ci <- ifelse(
      x_sum == 0,
      0,
      stats::qbeta(alpha / 2, x_sum + 0.5, n - x_sum + 0.5)
    )
    u_ci <- ifelse(
      x_sum == n,
      1,
      stats::qbeta(1 - alpha / 2, x_sum + 0.5, n - x_sum + 0.5)
    )

    c(l_ci, u_ci)
  }

  attr(prop_ci, "label") <- d_proportion(
    conf_level = conf_level,
    prop_ci_method = prop_ci_method,
    long = TRUE
  )

  results <- list(
    "n" = x_sum,
    "prop" = p_hat,  # Note: We always return the same response proportion estimate.
    "n_prop" = c(x_sum, p_hat),
    "prop_ci" = prop_ci
  )

}

```

#### `d_proportion`

Helper function, kept as is from old tern.

```{r d_proportion}
d_proportion <- function(conf_level,
                         prop_ci_method,
                         long = FALSE) {
  label <- paste0(conf_level * 100, "% CI")
  if (long) label <- paste(label, "for Response Rates")
  method_part <- switch(
    prop_ci_method,
    "clopper-pearson" = "Clopper-Pearson",
    "waldcc" = "Wald, with correction",
    "wald" = "Wald, without correction",
    "wilson" = "Wilson",
    "agresti-coull" = "Agresti-Coull",
    "jeffreys" = "Jeffreys",
    stop(paste(prop_ci_method, "does not have a description"))
  )
  label <- paste0(label, " (", method_part, ")")
}
```

### Applications

Applications will eventually used for tests and examples.

#### `estimate_proportion`

```{r estimate_proportion}
dta_test <- data.frame(X = c(1, 0, 1, 0))
l <- estimate_proportion(lyt = NULL, vars = "X")

build_table(lyt = l, df = dta_test)
```

#### `s_proportion`

```{r s_proportion}
s_proportion(c(1, 0, 1, 0))
```

#### `afun` construction

```{r afun_s_proportion}
(
  format_wrap_x(
    s_proportion,
    formats =  c(
      n = "xx", prop = "xx.x%", n_prop = "xx (xx.xx%)",
      prop_ci = "(xx.xx, xx.xx)"
    ),
    indent_mods =  c(n = 0L, prop = 0L, n_prop = 0L, prop_ci = 0L)
  )
)(c(1, 0, 1, 0))
```


Estimate proportion diff
------------------------

Based on the existing (minor refactoring):

- topic name: `Responder proportion difference`
- `estimate_proportion_diff`, this layer function  needs:
    + `s_proportion_diff`, needs:
        - `d_proportion_diff` for row labeling.
    + `format_wrap_x_comp_ref`

### Functions {.tabset}

#### `prop_diff_*` {.tabset .tabset-pills}

I broke down the former function `s_proportion_diff` into individualized
proportion functions. Advantages:

- smaller functions
- reusable bits.
- I will probably extend the approach to first `s_proportion`.

##### `prop_diff_wald`

```{r prop_diff_wald}
prop_diff_wald <- function(rsp,
                           grp,
                           conf_level,
                           correct) {

  p_grp <- tapply(rsp, grp, mean)
  list(
    diff = unname(diff(p_grp)),
    diff_ci = stats::prop.test(
      table(grp, rsp),
      correct = correct,
      conf.level = conf_level
    )$conf.int[1:2]
  )

}
```

##### `prop_diff_ha`

```{r prop_diff_ha}
prop_diff_ha <- function(rsp,
                         grp,
                         conf_level) {

  n_grp <- tapply(rsp, grp, length)
  p_grp <- tapply(rsp, grp, mean)
  diff_p <- unname(diff(p_grp))
  z <- stats::qnorm((1 + conf_level) / 2)

  err <- 1 /
    (2 * min(n_grp)) + z * sqrt(sum(p_grp * (1 - p_grp) / (n_grp - 1)))

  l_ci <- max(-1, diff_p - err)
  u_ci <- min(1, diff_p + err)

  list(
    "diff" = diff_p,
    "diff_ci" = c(l_ci, u_ci)
  )

}
```

##### `prop_wilson`

```{r prop_wilson}
prop_wilson <- function(rsp,
                        conf_level){

  n <- length(rsp)
  x_sum <- sum(rsp)

  y <- prop.test(x_sum, n, correct = FALSE, conf.level = conf_level)$conf.int
  y <- as.numeric(y)

  y

}
```

##### `prop_diff_nc`

```{r prop_diff_nc}
prop_diff_nc <- function(rsp,
                         grp,
                         conf_level) {

  # Source:
  # https://www.lexjansen.com/wuss/2016/127_Final_Paper_PDF.pdf

  p_grp <- tapply(rsp, grp, mean)
  diff_p <- unname(diff(p_grp))

  x_grp <- split(rsp, f = grp)
  ci_grp <- lapply(x_grp, FUN = prop_wilson, conf_level = conf_level)

  l1 <- ci_grp[[1]][1]
  u1 <- ci_grp[[1]][2]
  l2 <- ci_grp[[2]][1]
  u2 <- ci_grp[[2]][2]
  l_ci <- max(-1, diff_p - sqrt((u1 - p_grp[1])^2 + (p_grp[2] - l2)^2))
  u_ci <- min(1, diff_p + sqrt((p_grp[1] - l1)^2 + (u2 - p_grp[2])^2))
  list(
    "diff" = diff_p,
    "diff_ci" = c(l_ci, u_ci)
  )
}
```

##### `prop_diff_cmh`

```{r prop_diff_cmh}
# prop_diff_cmh <- s_adj_proportion_diff
prop_diff_cmh <- function(rsp, grp, strata, conf_level = 0.95) {

  if (any(tapply(rsp, strata, length) < 5)) {
    warning("Less than 5 observations in some strata.")
  }

  # first dimension: FALSE, TRUE
  # 2nd dimension: CONTROL, TX
  # 3rd dimension: levels of strat
  t_tbl <- table(rsp, grp, strata)

  n1 <- colSums(t_tbl[1:2, 1, ])
  n2 <- colSums(t_tbl[1:2, 2, ])

  p1 <- t_tbl[2, 1, ] / n1
  p2 <- t_tbl[2, 2, ] / n2

  # CMH weights
  wt <- (n1 * n2 / (n1 + n2)) / sum(n1 * n2 / (n1 + n2))

  est1 <- sum(wt * p1)
  est2 <- sum(wt * p2)

  estimate <- c(est1, est2)
  names(estimate) <- levels(grp)

  se1 <- sqrt(sum(wt^2 * p1 * (1 - p1) / n1))
  se2 <- sqrt(sum(wt^2 * p2 * (1 - p2) / n2))

  z <- qnorm((1 + conf_level) / 2)
  err1 <- z * se1
  err2 <- z * se2

  ci1 <- c((est1 - err1), (est1 + err1))
  ci2 <- c((est2 - err2), (est2 + err2))

  estimate_ci <- list(ci1, ci2)
  names(estimate_ci) <- levels(grp)

  diff_est <- est2 - est1
  se_diff <- sqrt(sum(((p1 * (1 - p1) / n1) + (p2 * (1 - p2) / n2)) * wt^2))

  diff_ci <- c(diff_est - z * se_diff, diff_est + z * se_diff)

  list(
    prop = estimate,
    prop_ci = estimate_ci,
    diff = diff_est,
    diff_ci = diff_ci
  )

}
```

#### `s_proportion_diff`

```{r s_proportion_diff}
s_proportion_diff <- function(df,
                              .var,
                              .ref_group,
                              .in_ref_col,
                              strata = NULL,
                              conf_level = 0.95,
                              diff_ci_method = c(
                                "wald", "waldcc", "cmh",
                                "anderson-hauck", "ha", "newcombe"
                              )
) {

  cat("===> In sfun: Add the assertthat section.\n")
  y <- list(diff = NULL, diff_ci = NULL)

  if (.in_ref_col) return(y)

  rsp <- c(df[[.var]], .ref_group[[.var]])
  grp <- rep(c("Not-ref", "ref"), c(nrow(df), nrow(.ref_group)))

  if (!is.null(strata))
    strata <- c(interaction(df[[strata]]), interaction(.ref_group[[strata]]))

  y <- switch(
    diff_ci_method,
    wald = prop_diff_wald(rsp, grp, conf_level, correct = FALSE),
    waldcc = prop_diff_wald(rsp, grp, conf_level, correct = TRUE),
    ha = prop_diff_ha(rsp, grp, conf_level),
    `anderson-hauck` = prop_diff_ha(rsp, grp, conf_level),
    newcombe = prop_diff_nc(rsp, grp, conf_level),
    cmh = prop_diff_cmh(rsp, grp, strata, conf_level)[c("diff", "diff_ci")]
  )

  print(y)
  y

}
```

#### `estimate_proportion_diff`

```{r estimate_proportion_diff}
estimate_proportion_diff<- function(lyt,
                                    vars,
                                    ...) {

  afun <- format_wrap_df(
    sfun = s_proportion_diff,
    formats =  c(diff = "xx.xx", diff_ci = "xx.xx - xx.xx"),
    indent_mods = c(diff = 0L, diff_ci = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}
```


### Applications


```{r estimate_proportion_diff_app}
library(assertthat)
ref <- levels(ADRS_f$ARMCD)[1]
split_cols_by(lyt = NULL, var = "ARMCD", ref_group = ref) %>%
  add_colcounts() %>%
  estimate_proportion_diff(
    vars = "is_rsp",
    diff_ci_method = c(
      "wald", "waldcc", "ha", "anderson-hauck", "newcombe", "cmh"
      )[6],
    strata = "SEX"
  ) %>%
  build_table(df = ADRS_f) %>%
  as_html

```

Test proportion diff
--------------------

### Functions {.tabset}

#### Topic intro

```{r}
#' Difference Test for Two Proportions
#'
#' Various tests were implemented to test the difference between two
#' proportions.
#'
#' @template formatting_arguments
#'
#' @name prop_diff_test
#'
NULL
```

#### `d_test_proportion_diff`

Not exported.

```{r}
#' Description of the Test Between Two Proportions
#'
#' This is an auxiliary function that describes the analysis in
#  `s_test_proportion_diff`.
#'
#' @inheritParams s_test_proportion_diff
#' @return String describing the test from which the p-value is derived.
d_test_proportion_diff <- function(method) {
  meth_part <- switch(
    method,
    "schouten" = "Chi-Squared Test with Schouten Correction",
    "chisq" = "Chi-Squared Test",
    "cmh" = "Cochran-Mantel-Haenszel Test",
    "fisher" = "Fisher's Exact Test",
    stop(paste(method, "does not have a description"))
  )
  paste0("p-value (", meth_part, ")")

}
```


#### `prop_*` {.tabset .tabset-pills}

##### `prop_chisq`

```{r}
#' @describeIn prop_diff_test performs Chi-Squared test.
#'   Internally calls [stats::prop.test()]
#' @param tbl (`matrix`)\cr
#'   with two groups in rows and the binary response (`TRUE`/`FALSE`) in
#'   columns.
#' @importFrom stats prop.test
#' @export
#' @examples
#' A <- 20
#' B <- 20
#' set.seed(1)
#' rsp <- c(
#'   sample(c(TRUE, FALSE), size = A, prob = c(3/4, 1/4), replace = TRUE),
#'   sample(c(TRUE, FALSE), size = A, prob = c(1/2, 1/2), replace = TRUE)
#' )
#' grp <- c(rep("A", A), rep("B", B))
#' tbl <- table(grp, rsp)
#' prop_chisq(tbl)
#'
prop_chisq <- function(tbl) stats::prop.test(tbl, correct = FALSE)$p.value
```

##### `prop_cmh`

```{r}
#' @describeIn prop_diff_test performs stratified Cochran-Mantel-Haenszel test.
#'   Internally calls [stats::mantelhaen.test()].
#' @param tbl (`array`)\cr
#'   with two groups in rows, the binary response (`TRUE`/`FALSE`) in
#'   columns, the strata in third dimension.
#' @importFrom stats mantelhaen.test
#' @export
#' @examples
#' rsp <- sample(c(TRUE, FALSE), 100, TRUE)
#' grp <- factor(rep(c("A", "B"), each = 50))
#' strata <- factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' tbl <- table(grp, rsp, strata)
#' prop_cmh(tbl)
#'
prop_cmh <- function(tbl) {

  if (any(apply(tbl, MARGIN = 3, sum) < 5))
    warning("<5 data points in some strata. CMH test may be incorrect.")

  stats::mantelhaen.test(tbl, correct = FALSE)$p.value

}
```

##### `prop_fisher`

```{r}
#' @describeIn prop_diff_test performs the Fisher's exact test.
#'   Internally calls [stats::fisher.test()]
#' @inheritParams prop_chisq
#' @importFrom stats fisher.test
#' @export
#' @examples
#'
#' A <- 20
#' B <- 20
#' set.seed(1)
#' rsp <- c(
#'   sample(c(TRUE, FALSE), size = A, prob = c(3/4, 1/4), replace = TRUE),
#'   sample(c(TRUE, FALSE), size = A, prob = c(1/2, 1/2), replace = TRUE)
#' )
#' grp <- c(rep("A", A), rep("B", B))
#' tbl <- table(grp, rsp)
#' prop_fisher(tbl)
#'
prop_fisher <- function(tbl) stats::fisher.test(tbl)$p.value
```

##### `prop_schouten`

```{r}
#' @describeIn prop_diff_test performs the Chi-Squared test with Schouten
#'   correction.
#' @inheritParams prop_chisq
#' @export
#' @examples
#'
#' A <- 20
#' B <- 20
#' set.seed(1)
#' rsp <- c(
#'   sample(c(TRUE, FALSE), size = A, prob = c(3/4, 1/4), replace = TRUE),
#'   sample(c(TRUE, FALSE), size = A, prob = c(1/2, 1/2), replace = TRUE)
#' )
#' grp <- c(rep("A", A), rep("B", B))
#' tbl <- table(grp, rsp)
#' prop_schouten(tbl)
#'
prop_schouten <- function(tbl) {

  # Source: STREAM v2
  #nolint start
  # https://github.roche.com/MDIS/stream2/blob/82c6c54ea6c61d11746af3b413ad6b1b213096cd/app/macro/str_tlg_method_resp.sas#L1623
  #nolint end
  count_1_1 <- tbl[1, "FALSE"]
  count_1_2 <- tbl[1, "TRUE"]
  count_2_1 <- tbl[2, "FALSE"]
  count_2_2 <- tbl[2, "TRUE"]

  t_schouten <- (count_1_1 + count_1_2 + count_2_1 + count_2_2 - 1) *
    (abs(count_2_2 * count_1_1 - count_1_2 * count_2_1) -
       0.5 * min(count_1_1 + count_1_2, count_2_1 + count_2_2))^2 /
    ((count_1_1 + count_1_2) * (count_2_1 + count_2_2) *
       (count_1_2 + count_2_2) * (count_1_1 + count_2_1))

  1 - stats::pchisq(t_schouten, df = 1)

}
```

#### `s_test_proportion_diff` 

```{r}
#' @describeIn prop_diff_test Statistics function which test the difference
#'  between two proportions.
#'
#' @inheritParams argument_convention
#' @param .ref_group The data corresponding to the reference group.
#' @param .in_ref_col Logical to specify result in reference column.
#' @param diff_ci_method The method used for the confidence interval estimation.
#' @param method (`string`)\cr
#'   one of (`chisq`, `cmh`, `fisher`, `schouten`; specifies the test used
#'   to calculate the p-value.
#'
#' @return Named `list` with a single item `pval` with an attribute `label`
#'   describing the method used. The p-value tests the null hypothesis that
#'   proportions in two groups are the same.
#' @export
#' @examples
#'
#' dta <- data.frame(
#'   rsp = sample(c(TRUE, FALSE), 100, TRUE),
#'   grp = factor(rep(c("A", "B"), each = 50)),
#'   strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' )
#'
#' s_test_proportion_diff(
#'   df = subset(dta, grp == "A"),
#'   .var = "rsp",
#'   .ref_group = subset(dta, grp == "B"),
#'   .in_ref_col = FALSE,
#'   variables = list(strata = "strat"),
#'   method = "cmh"
#' )
#'
s_test_proportion_diff <- function(df,
                                   .var,
                                   .ref_group,
                                   .in_ref_col,
                                   variables = list(strata = NULL),
                                   method = c(
                                     "schouten", "chisq", "cmh", "fisher"
                                     )
                                   ) {

  method <- match.arg(method)
  y <- list(pval = "")

  if (!.in_ref_col) {

    rsp <- c(.ref_group[[.var]], df[[.var]])
    grp <- factor(
      rep(c("ref", "Not-ref"), c(nrow(.ref_group), nrow(df))),
      levels = c("ref", "Not-ref")
    )

    if (!is.null(variables$strata)) {
      strata <- variables$strata
      strata <- c(interaction(.ref_group[[strata]]), interaction(df[[strata]]))
    }

    tbl <- if(method == "cmh")
      table(grp, rsp, strata)
    else
      table(grp, rsp)

    y$pval <- switch(
      method,
      chisq = prop_chisq(tbl),
      cmh = prop_cmh(tbl),
      fisher = prop_fisher(tbl),
      schouten = prop_schouten(tbl)
    )

  }

  y$pval <- with_label(y$pval, d_test_proportion_diff(method))
  y
}

```

#### `test_proportion_diff`

```{r test_proportion_diff}
#' @describeIn prop_diff_test Layout creating function which can be used for
#'   creating tables, which can take statistics function arguments and
#'   additional format arguments.
#' @export
#' @examples
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   test_proportion_diff(
#'     vars = "rsp",
#'     method = "fisher"
#'   )
#'
#' build_table(l, df = dta)
#'
test_proportion_diff <- function(lyt,
                                 vars,
                                 ...) {

  afun <- format_wrap_df(
    sfun = s_test_proportion_diff,
    formats =  c(pval = "x.xxxx | (<0.0001)"),
    indent_mods = c(pval = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}
```


### Applications

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

s_test_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  variables = list(strata = "strat"),
  method = "cmh"
)

```

```{r}
l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  test_proportion_diff(
    vars = "rsp",
    method = "fisher"
  )

build_table(l, df = dta)
```


Estimate odds ratio (OUT of REVIEW scope)
-------------------

### Functions {.tabset}

#### Topic intro

```{r}
#' OR: Comparison of Odds Ratio
#'
#' Compares bivariate responses between two groups in terms of odds ratios
#' along with a confidence interval.
#'
#' @details This function uses either logistic regression for unstratified
#'   analyses, or conditional logistic regression for stratified analyses.
#'   The Wald confidence interval with the specified confidence level is
#'   calculated. Note that, for stratified analyses, there is currently no
#'   implementation for conditional likelihood confidence intervals,
#'   therefore the likelihood confidence interval as an option is not yet
#'   available. Besides, when `rsp` contains only responders or non-responders,
#'   then the result values will be `NA`, because no odds ratio estimation is
#'   possible.
#'
#' @template formatting_arguments
#'
#' @name odds_ratio
#' @md
#'
NULL
```

#### `or_*` {.tabset .tabset-pills}

##### `or_clogit`

```{r}
library(survival)
#' OR with Strata by Conditional Likelihood
#'
#' The odds ratio is estimated by conditional likelihood using
#' [survival::clogit()].
#'
#' @inheritParams argument_convention
#' @param data (`data frame`)\cr
#'   includes the three variables `rsp`, `grp` and `strata`.
#' @importFrom survival strata clogit coxph
or_clogit <- function(data, conf_level) {

  # Deviation from convention: `survival::strata` must be simply `strata`.
  formula <- stats::as.formula("rsp ~ grp + strata(strata)")
  model_fit <- survival::clogit(formula = formula, data = data)

  list(
    or_ci = c(
      exp(stats::coef(model_fit)),
      exp(stats::confint(model_fit, level = conf_level))
    )
  )

}
```

##### `or_glm`

```{r}
#' OR by `glm`
#'
#' The OR is estimated using [stats::glm()].
#'
#' @inheritParams argument_convention
#' @param data (`data frame`)\cr
#'   includes the three variables `rsp`, `grp` and `strata`.
#' @importFrom stats glm
or_glm <- function(data, conf_level) {

  formula <- as.formula("rsp ~ grp")
  model_fit <- stats::glm(
    formula = formula,
    data = data,
    family = binomial(link = "logit")
  )

  # Note that here we need to discard the intercept.
  list(
    or_ci = c(
      exp(stats::coef(model_fit)[-1]),
      # We use `confint.default` to choose the Wald confidence interval.
      exp(stats::confint.default(model_fit, level = conf_level)[-1, , drop = FALSE])
    )
  )

}

```

#### `s_odds_ratio`

```{r}
#' @describeIn odds_ratio Statistics function which estimates the odds ratio
#'   between a treatment and a control.
#' @export
#' @examples
#'
#' dta <- data.frame(
#'   rsp = sample(c(TRUE, FALSE), 100, TRUE),
#'   grp = factor(rep(c("A", "B"), each = 50)),
#'   strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' )
#'
#' s_odds_ratio(
#'   df = subset(dta, grp == "A"),
#'   .var = "rsp",
#'   .ref_group = subset(dta, grp == "B"),
#'   .in_ref_col = FALSE,
#'   variables = list(strata = "strat")
#' )
#'
s_odds_ratio <- function(df,
                         .var,
                         .ref_group,
                         .in_ref_col,
                         variables = list(strata = NULL),
                         conf_level = 0.95) {

  y <- list(or_ci = "")

  if (!.in_ref_col) {

    data <- data.frame(
      rsp = c(.ref_group[[.var]], df[[.var]]),
      grp = factor(
        rep(c("ref", "Not-ref"), c(nrow(.ref_group), nrow(df))),
        levels = c("ref", "Not-ref")
      )
    )

    if (!is.null(variables$strata)) {
      strata <- variables$strata
      data$strata <- c(
        interaction(.ref_group[[strata]]), interaction(df[[strata]])
      )
    }

    y <- if (is.null(data$strata))
      or_glm(data, conf_level = conf_level)
    else
      or_clogit(data, conf_level = conf_level)

  }

  y$or_ci <- with_label(y$or_ci, "Odds Ratio (CI)")
  y

}

```

#### `estimation_odds_ratio`

```{r}
#' @describeIn abnormal Layout creating function which can be used for creating
#'   tables, which can take statistics function arguments and additional format
#'   arguments (see below).
#' @export
#' @examples
#'
#' dta <- data.frame(
#'   rsp = sample(c(TRUE, FALSE), 100, TRUE),
#'   grp = factor(rep(c("A", "B"), each = 50)),
#'   strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
#' )
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   estimation_odds_ratio(vars = "rsp")
#'
#' build_table(l, df = dta)
#'
#' l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
#'   estimation_odds_ratio(vars = "rsp", variables = list(strata = "strat"))
#'
#' build_table(l, df = dta)
#'
estimation_odds_ratio <- function(lyt,
                                  vars,
                                  ...) {

  afun <- format_wrap_df(
    sfun = s_odds_ratio,
    formats =  c(or_ci = function(x, output) {
      x <- round(x, 2)
      paste0(x[1], " (", x[2], " - ", x[3], ")")
    }
    ),
    indent_mods = c(or_ci = 0L)
  )

  analyze(
    lyt,
    vars,
    afun = afun,
    extra_args = list(...)
  )

}

```

### Application

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

s_odds_ratio(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  variables = list(strata = "strat")
)
```

```{r}
dta <- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  estimation_odds_ratio(vars = "rsp")

build_table(l, df = dta)

l <- split_cols_by(lyt = NULL, var = "grp", ref_group = "B") %>%
  estimation_odds_ratio(vars = "rsp", variables = list(strata = "strat"))

build_table(l, df = dta)

```


Estimate multinomial response
-----------------------------


References
==========
