% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tabulate_aggregation_functions.R
\name{a_mean_sd}
\alias{a_mean_sd}
\alias{a_median}
\alias{a_n_true_and_freq}
\alias{a_count}
\alias{a_q1q3}
\alias{a_iqr}
\alias{a_range}
\title{\code{rtabulate}-friendly aggregation functions (\verb{a_*})}
\usage{
a_mean_sd(x, na.rm = TRUE, na = NA, rcell = FALSE)

a_median(x, na.rm = TRUE, na = NA, rcell = FALSE)

a_n_true_and_freq(x, na.rm = TRUE, na = NA, rcell = FALSE)

a_count(x, na.rm = TRUE, na = NA, rcell = FALSE)

a_q1q3(x, na.rm = TRUE, na = NA, rcell = FALSE, type = 7)

a_iqr(x, na.rm = TRUE, na = NA, rcell = FALSE, type = 7)

a_range(x, na.rm = TRUE, na = NA, rcell = FALSE)
}
\arguments{
\item{x}{A vector of numeric values to be aggregated.}

\item{na.rm}{A logical value indicating whether NA values should be stripped
before the computation proceeds. Note that in \code{a_count}, it indicates
whether or not to return NA if all data are missing.}

\item{na}{The string to use for missing values.}

\item{rcell}{A logical value indicated when the return value should be a
formatted \code{rcell}.}

\item{type}{An integer between 1 and 9 to select the quantile algorithm,
see \code{\link[stats:quantile]{stats::quantile()}}.}
}
\value{
Either a numeric or a \code{rcell}.
}
\description{
These functions enhance the control of missing data, including \code{rcell}
dedicated formats and are intended to be used with \code{rtables::rtabulate}.
Included:
\itemize{
\item \code{a_mean_sd} mean along with standard deviation.
\item \code{a_median} median.
\item \code{a_n_true_and_freq} number of positive cases and frequency.
\item \code{a_count} number of items.
\item \code{a_q1q3} first and third quartiles.
\item \code{a_iqr} interquartile range.
\item \code{a_range} range.
}
}
\details{
These functions offer similar control over the management of missing values,
and the possibility to return a \code{rcell} object.
}
\note{
These functions come as a replacement of non-exported functions:
\itemize{
\item \code{a_mean_sd} replaces \code{mean_sd}, \code{mean_sd2}, \code{mean_sd3}.
\item \code{a_median} replaces \code{median_t2}, \code{median_t3}.
\item \code{a_n_true_and_freq} replaces \code{positives_and_proportion},
\code{positives_and_proportion2}, \code{positives_and_proportion3}.
\item \code{a_count} replaces \code{n_count}, \code{n_not_na2}, \code{n_not_na3}.
\item \code{a_q1q3} replaces \code{q1_q3}.
\item \code{a_iqr} replaces \code{iqr_num}, \code{iqr_num2}, \code{iqr_num3}.
\item \code{a_range} range \code{range_t2}, \code{range_t3}.
}
}
\examples{
# Data
# ----

dta <- list(
    a = c(1, 2, 3),
    b = c(1, 2, NA),
    c = c(1, 1, NA),
    d = c(1),
    e = c(),
    f = c(NA, NA),
    g = NULL
  )

# Mean and standard deviation
# ---------------------------
lapply(dta, a_mean_sd)

# Median
# ------
lapply(dta, a_median, rcell = TRUE, na = "NE")

# Count positive cases and proportion
# -----------------------------------
booleans <- list(
  a = c(TRUE, TRUE, TRUE),
  b = c(FALSE, FALSE, FALSE),
  c = c(TRUE, FALSE, NA),
  d = c(),
  e = NULL
)

lapply(
  booleans,
  a_n_true_and_freq,
  na.rm = FALSE,
  na = "NE",
  rcell = TRUE
  )

# Count items with explicit rules for NA
# --------------------------------------
lapply(dta, a_count, na.rm = FALSE, rcell = TRUE, na = "NE")

# First and third quartiles
# -------------------------
dta_quant <- list(
  a = c(1, 1, 2, 3, 4, 4, 5, 7, 8, 9),    # n = 10
  b = c(1, 1, 2, 3, 4, 4, 5, 7, 8, 9, 9), # n = 11
  c = c(1, 1, 2, 3, 4, 4, 5, 7, 8, NA),   # n = 9 + 1 NA
  d = c(NA, NA),
  e = c(),
  f = NULL
)
lapply(dta_quant, a_q1q3, na = "NE", rcell = TRUE, na.rm = FALSE)

# Interquartile range
# --------------------
lapply(dta_quant, a_iqr, rcell = TRUE)

# Range
# -----
lapply(dta_quant, a_range, rcell = TRUE, na = "not avail.")
}
