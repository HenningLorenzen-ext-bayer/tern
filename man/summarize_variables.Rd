% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/s_summary.R, R/summarize_vars.R
\name{summarize_variables}
\alias{summarize_variables}
\alias{s_summary}
\alias{s_summary.numeric}
\alias{summarize_vars}
\title{Summarize variables}
\usage{
s_summary(x, na.rm = TRUE)

\method{s_summary}{numeric}(x, na.rm = TRUE)

summarize_vars(lyt, vars, ...)
}
\arguments{
\item{x}{a vector.}

\item{na.rm}{(\code{logical})

Indicating whether \code{NA} values should be
stripped before the computation proceeds.}

\item{lyt}{layout object pre-data used for tabulation}

\item{vars}{character vector. Multiple variable names.}

\item{...}{arguments passed to \code{s_summary()}.}
}
\value{
If \code{x} is of class \code{numeric}, returns a list with named items:
\itemize{
\item \code{n}: the \code{\link[=length]{length()}} of \code{x}.
\item \code{mean_sd}: the \code{\link[=mean]{mean()}} and \code{\link[=sd]{sd()}}.
\item \code{median}: the \code{\link[=median]{median()}}.
\item \code{range}: the \code{\link[=range]{range()}}.
}
}
\description{
Produces an object description.
}
\section{Functions}{
\itemize{
\item \code{s_summary}: \code{s_summary} is a generic function to produce
an object description.

\item \code{s_summary.numeric}: Method for numeric class. Note that,
if \code{x} is an empty vector, \code{NA} is returned. This is the expected
feature so as to return \code{rcell} content in \code{rtables} when the
intersection of a column and a row delimits an empty data selection.
Also, when the \code{mean} function is applied to an empty vector, \code{NA} will
be returned instead of \code{NaN}, the latter being standard behavior in R.

\item \code{summarize_vars}: Adds a descriptive analyze layer to \code{rtables}
pipelines. The analysis is applied to a vector and return the summary,
in \code{rcells}. The ellipsis (\code{...}) conveys arguments to \code{\link[=s_summary]{s_summary()}}, for
instance \code{na.rm = FALSE} if missing data should be accounted for.
}}

\section{Formatting arguments}{

These additional formatting arguments can be passed to the layout creating function:
\describe{
  \item{.stats}{(\code{character})\cr names of the statistics to use}
  \item{.indent_mods}{(\code{integer})\cr named vector of indent modifiers for the labels}
  \item{.formats}{(\code{character} or \code{list})\cr named vector of formats for the statistics}
  \item{.labels}{(\code{character})\cr named vector of labels for the statistics (without indent)}
}
}

\examples{
# `s_summary.numeric`

## Basic usage: empty numeric returns NA-filled items.
s_summary(numeric())

## Management of NA values.
x <- c(NA_real_, 1)
s_summary(x, na.rm = TRUE)
s_summary(x, na.rm = FALSE)

x <- c(NA_real_, 1, 2)
s_summary(x)

## Benefits in `rtables` contructions:
require(rtables)
dta_test <- data.frame(
  Group = rep(LETTERS[1:3], each = 2),
  sub_group = rep(letters[1:2], each = 3),
  x = 1:6
)

## The summary obtained in with `rtables`:
split_cols_by(lyt = NULL, var = "Group") \%>\%
  split_rows_by(var = "sub_group") \%>\%
  analyze(vars = "x", afun = s_summary) \%>\%
  build_table(df = dta_test)

## By comparison with `lapply`:
X <- split(dta_test, f = with(dta_test, interaction(Group, sub_group)))
lapply(X, function(x) s_summary(x$x))


# `summarize_vars()` in rtables pipelines

## Fabricated dataset.
dta_test <- data.frame(
  USUBJID = rep(1:6, each = 3),
  PARAMCD = rep("lab", 6*3),
  AVISIT  = rep(paste0("V", 1:3), 6),
  ARM     = rep(LETTERS[1:3], rep(6, 3)),
  AVAL    = c(9:1, rep(NA, 9))
)

## Default output within a `rtables` pipeline.
l <- split_cols_by(lyt = NULL, var = "ARM") \%>\%
  split_rows_by(var = "AVISIT") \%>\%
  summarize_vars(vars = "AVAL")

build_table(l, df = dta_test)

## Select and format statistics output.
l <- split_cols_by(lyt = NULL, var = "ARM") \%>\%
  split_rows_by(var = "AVISIT") \%>\%
  summarize_vars(
    vars = "AVAL",
    .stats = c("n", "mean_sd"),
    .formats = c("mean_sd" = "xx.x, xx.x"),
    .labels = c(n = "n", mean_sd = "Mean, SD")
  )

results <- build_table(l, df = dta_test)
as_html(results)

## Use arguments interpreted by `s_summary`.
l <- split_cols_by(lyt = NULL, var = "ARM") \%>\%
  split_rows_by(var = "AVISIT") \%>\%
  summarize_vars(vars = "AVAL", na.rm = FALSE)

results <- build_table(l, df = dta_test)
Viewer(results)
}
