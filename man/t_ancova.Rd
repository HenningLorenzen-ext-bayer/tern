% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/t_ancova.R
\name{t_ancova}
\alias{t_ancova}
\title{Summary table for analysis of covariance (ANCOVA).}
\usage{
t_ancova(formula, data, row_by, col_N, conf_level = 0.95, table_tree = FALSE)
}
\arguments{
\item{formula}{A \code{formula} corresponding to the investigated \code{\link[stats:lm]{linear model}}.
The left-hand side must include the dependent variable. The right-hand side must include the group variable
name wrapped in the special \code{arm()}.}

\item{data}{A \code{data.frame} which includes all the variables that are called in \code{formula}.}

\item{row_by}{(\code{factor} or \code{data.frame})\cr
Defines how data from `data` is split into sub-tables. Dimensions must match
dimensions of `data` and no missing values are allowed. Multi-level nesting is possible when
`row_by` is a \code{data.frame}. Columns should be ordered with the first column specifying
the first variable to split by and the last column specifying the last variable to split by.}

\item{col_N}{(\code{integer} vector)\cr
Contains the reference population per level of \code{col_by}. This by default is often
set to \code{get_N(col_by)}. Names of the list are ignored, they are added in the order they appear.
The default may not appropriate and should be modified by the user when \code{col_by} contains
more than one record per subject.}

\item{conf_level}{confidence level of the interval.}

\item{table_tree}{(\code{logical} value)\cr
If \code{FALSE} then a single \code{rtable} gets returned, if \code{TRUE} a
\code{\link{node}} object gets returned with the elementary \code{rtable} objects.}
}
\value{
Either \code{rtable} or \code{node} object (see `table_tree` argument).
  For every unique combination of levels of `row_by` an ANCOVA table using \code{\link{t_el_ancova}}
  will be created. The individual tables are then stacked together.
}
\description{
This is a wrapper around the basic \code{\link{t_el_ancova}} function with the difference that it has a `row_by`
argument. This can e.g. be used to analyze multiple endpoints and/or multiple timepoints within the same response
variable.
}
\examples{
library(random.cdisc.data)
library(dplyr)

ADSL <- radsl(cached = TRUE)
ADQS <- radqs(cached = TRUE) \%>\%
  dplyr::filter(AVISIT == "WEEK 1 DAY 8")

# Multiple endpoints.
ADQS_week1day8 <- dplyr::filter(ADQS, AVISIT == "WEEK 1 DAY 8")
t_ancova(
  formula = CHG ~ BASE + STRATA1 + arm(ARMCD),
  data = ADQS_week1day8,
  row_by = ADQS_week1day8$PARAMCD,
  col_N = table(ADSL$ARMCD)
)

# Multiple visits (in this data set there is only one visit, though).
ADQS_fksifwb <- dplyr::filter(ADQS, PARAMCD == "FKSI-FWB")
t_ancova(
  formula = CHG ~ BASE + STRATA1 + arm(ARMCD),
  data = ADQS_fksifwb,
  row_by = ADQS_fksifwb$AVISIT,
  col_N = table(ADSL$ARMCD)
)

# Multiple timepoints and visits.
t_ancova(
  formula = CHG ~ BASE + STRATA1 + arm(ARMCD),
  data = ADQS,
  row_by = ADQS[, c("PARAMCD", "AVISIT")],
  col_N = table(ADSL$ARMCD)
)
}
