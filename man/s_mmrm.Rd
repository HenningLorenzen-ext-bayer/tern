% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/s_mmrm.R
\name{s_mmrm}
\alias{s_mmrm}
\title{Summary function for an MMRM analysis}
\usage{
s_mmrm(
  vars = list(response = "AVAL", covariates = c(), id = "USUBJID", arm = "ARM", visit =
    "AVISIT"),
  data,
  conf_level = 0.95,
  cor_struct = "unstructured",
  weights_emmeans = "proportional",
  optimizer = "automatic"
)
}
\arguments{
\item{vars}{a \code{list} specifying the variables in the MMRM. The following elements need
to be included as character vectors and match corresponding columns in \code{data}:
\describe{
\item{response}{the response variable}
\item{covariates}{the additional covariate terms (might also include interactions)}
\item{id}{the subject ID variable}
\item{arm}{the treatment group variable (factor)}
\item{visit}{the visit variable (factor)}
}
Note that the main effects and interaction of `arm` and `visit` are by default included in the model.}

\item{data}{a \code{data.frame} with all the variables specified in
\code{vars}. Records with missing values in any independent variables
will be excluded.}

\item{conf_level}{confidence level. Must be number greater than 0 and less
than 1. (Default: 0.95)}

\item{cor_struct}{a string specifying the correlation structure, defaults to
\code{"unstructured"}. See the details.}

\item{weights_emmeans}{argument from \code{\link[emmeans]{emmeans}}, "proportional" by default.}

\item{optimizer}{a string specifying the optimization algorithm which should be used. By default, "automatic"
will (if necessary) try all possible optimization algorithms and choose the best result. If another algorithm
is chosen and does not give a valid result, an error will occur.}
}
\value{
An \code{mmrm} object which is a list with MMRM results:
\describe{
  \item{fit}{The \code{lmerModLmerTest} object which was fitted to the data. Note that the attribute \code{optimizer}
    contains the finally used optimization algorithm, which can be useful for refitting the model later on.}
  \item{cov_estimate}{The matrix with the covariance matrix estimate.}
  \item{lsmeans}{This is a list with data frames \code{estimate} and \code{contrast}.}
  \item{vars}{The variable list.}
  \item{ref_level}{The reference level for the arm variable, which is always the first level.}
  \item{conf_level}{The confidence level which was used to construct the confidence intervals.}
}
}
\description{
Summary function for an MMRM analysis
}
\details{
Only Satterthwaite adjusted degrees of freedom (d.f.) are supported, because they
  match the results obtained in SAS (confirmed for unstructured and compound symmetry correlation structures).

  For the correlation structure (\code{cor_struct}), the user can choose among the following options, sorted
  in descending number of variance parameters:
  \describe{
  \item{unstructured}{Unstructured covariance matrix. This is the most flexible choice and default.
     If there are \code{T} visits, then \code{T * (T+1) / 2} variance parameters are used.
     Note: the current actual implementation uses one more variance parameter, which does not have any
     effect of the results. Therefore we report here the actually relevant number of parameters.}
  \item{random-quadratic}{Random quadratic spline for the random effects of the time variable.
     7 variance parameters are used.}
  \item{random-slope}{Random slope for the random effects of the time variable. 4 variance parameters are used.}
  \item{compound-symmetry}{Constant correlation between visits. 2 variance parameters are used.}
  }

  For the \code{optimizer}, the user can choose among the following alternatives to the recommended "automatic":
  \describe{
  \item{nloptwrap_neldermead}{NLopt version of the Nelder-Mead algorithm (via package \code{nloptr})}
  \item{nloptwrap_bobyqa}{NLopt version of the BOBYQA algorithm (via package \code{nloptr})}
  \item{bobyqa}{BOBYQA algorithm (via package \code{minqa})}
  \item{nlminbwrap}{nlminb algorithm (wrapper for \code{\link[stats]{nlminb})}}
  \item{neldermead}{lme4 version of the Nelder-Mead algorithm with box constraints (via package \code{lme4})}
  \item{nmkbw}{Nelder-Mead algorithm (via package \code{dfoptim})}
  \item{optimx_lbfgsb}{L-BFGS-B algorithm (via package \code{optimx})}
  }
}
\examples{
library(random.cdisc.data)
library(dplyr)

adsl <- radsl(cached = TRUE)
adqs <- radqs(cached = TRUE)
adqs_f <- adqs \%>\%
  dplyr::filter(PARAMCD == "FKSI-FWB" & !AVISIT \%in\% c("BASELINE")) \%>\%
  droplevels() \%>\%
  dplyr::mutate(ARMCD = factor(ARMCD, levels = c("ARM B", "ARM A", "ARM C"))) \%>\%
  dplyr::mutate(
    AVISITN = rank(AVISITN) \%>\%
    as.factor() \%>\%
    as.numeric() \%>\%
    as.factor()
  )

mmrm_results <- s_mmrm(
  vars = list(
    response = "AVAL",
    covariates = c("STRATA1", "BMRKR2"),
    id = "USUBJID",
    arm = "ARMCD",
    visit = "AVISIT"
  ),
  data = adqs_f,
  cor_struct = "unstructured",
  weights_emmeans = "equal",
  optimizer = "nloptwrap_neldermead"  # Only to speed up this example.
)
}
