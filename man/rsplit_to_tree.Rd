% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aa_trees.R
\name{rsplit_to_tree}
\alias{rsplit_to_tree}
\title{Split list recursively according to by and return the associated tree}
\usage{
rsplit_to_tree(lst, by_lst, drop_empty_levels = TRUE, non_leaves_null = FALSE)
}
\arguments{
\item{lst}{list to split, \code{\link{esplit}} will be applied to all list elements}

\item{by_lst}{list of columns, each of which is a factor to recursively split by}

\item{drop_empty_levels}{whether to drop empty levels, this happens often when you have, e.g. two factors,
one with levels (\code{clA}, \code{clB}), the other with levels (\code{clA_1}, \code{clA_2}, \code{clB_1},
\code{clB_2}) and only the combinations \code{clA-clA_1}, \code{clA-clA_2}, \code{clB-clB_1}, \code{clB-clB_2}
appear out of the eight combinations.}

\item{non_leaves_null}{whether to assign \code{NULL} content to any non-leaves}
}
\value{
node object
}
\description{
Split list recursively according to by and return the associated tree
}
\examples{
tree <- rsplit_to_tree(
  1:5,
  by_lst = list(factor(c("M", "M", "F", "F", "F")), factor(c("O", "Y", "Y", "Y", "Y")))
)
summary(tree)
cat(displayable(tree))

by_lst <- list(
  factor(c(rep("clA", 4), rep("clB", 4))),
  factor(c(rep(c("A1", "A2"), 2), rep(c("B1", "B2"), 2)))
)
summary(rsplit_to_tree(1:8, by_lst))
summary(rsplit_to_tree(1:8, by_lst, drop_empty_levels = FALSE))
}
